---
title: "Exercícios - Módulo I"
author: "J van Melis"
date: "22/03/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Módulo I - Introdução ao R

Esse documento tem como objetivo mostrar alguns tutoriais e exercícios que devem ser feitos por você. Você pode realizar os tutoriais que se encontram aqui nesse documento em seu próprio computador utilizando o RStudio. Ao final, encontram-se exercícios que devem ser realizados por você, colocando as linhas de comando em um script (arquivo com extensão .r) e enviar para mim no e-mail jvmelis@gmail.com


As partes que estão em janelas são aquelas que podem ser repetidas em seu console. Exemplo: 

```{r results='hide'}
print("Hello!")
```


E aqeulas janelas que começam com `##` são aquelas que resultam do comando escrito na última janela mostrada anteriormente. Exemplo (*output* de `print("Hello!")`):

```{r echo = FALSE}
print("Hello!")
```


## Tutoriais

Nos exercícios que fizemos até agora, vocês utilizaram alguns operadores. Para relembrá-los, mostrarei cada um:

### Conceitos básicos

**Operadores Matemáticos**: São aqueles utilizados para realizar as operações matemáticas mais simples, como soma (`+`), subtração (`-`), multiplicação (`*`) e divisão (`/`). Podemos também incluir a exponenciação (`^`) nesse conjunto. A seguir, temos alguns exemplos de uso:

```{r}
23 + 45

105 - 81

12 * 5

15 / 3 
```

**Criar variáveis**
Como o R também é uma linguagem orientada a objetos, é importante a criação de objetos. Como todo objeto, podemos montar objetos que tenham características e tamanhos diferentes. Os objetos podem ser variáveis e, para atribuirmos um valor a uma variável, podemos utilizar os símbolos `=` ou `<-`, sendo que aquilo que se encontra do lado esquerdo é a variável e do lado esquerdo o valor (ou conjunto de valores) a ser atribuído à variável. 

Por exemplo: atribuir o valor numérico `2` a variável chamada `numero`:

Importante lembrar que o nome das variáveis **DEVEM**:
 
    1. Começar com ao menos uma letra (Não podem começar com números ou símbolos)
 
    2. Evite o uso de símbolos. Por exemplo: `#`, `@`, `!`,`$`, `%`, `&`, `*`, `+`, `-`,  `/`, `(`, `)`, além de acentos e espaços. Símbolo aceitável é `_`.
 
    3. Prefira nomes de variáveis que signifiquem algo e que sejam mais *únicos*. Por exemplo: `DNA_ind235` (DNA do indivíduo 235) ao invés de `gen1` (seria gene ou genoma?) ou `dna` (de quem? Vai ter mais do que uma extração de DNA?).
 
Quanto aos valores, eles podem ser um único valor (0 dimensões), um `vector` (1 dimensão: 1 x n), um `data.frame` (2 dimensões:  n linhas e m colunas, sendo que todas as colunas devem ter o mesmo número de linhas), além de `array` (mais do que duas dimensões) e `list` (objetos que podem ter elementos de diferentes tipos: `data.frame`, `vector`, valores, `array`, etc).

- Atribuindo um valor a uma variável:

```{r}
a <- 18.5
b <- 442L
c <- "Qualquer letr@ ou $ímbolo"
d <- TRUE
```

os valores são objetos que podem ter diferentes classes, as classes que construímos acima são de quatro tipos. Podemos ver as classes desses objetos usando a função `class()`:

```{r}
class(a)
class(b)
```

A diferença das classes `numeric` e `integer` é que a segunda classe é para número inteiros. No R, para que um número inteiro seja reconhecido como tal, usa-se a letra maiúscula **L** ao final do número (neste caso `442L`). Lembrando que o R usa numeração "americana" (dígitos separados por `.` e não `,`).

Ambos podem ser utilizados como valores numéricos em operações matemáticas:

```{r}
a*b
```

Os outros dois objetos não são numéricos, mas cada um tem sua peculiaridade:

```{r}
class(c)
class(d)
```


Para construir um objeto `character` basta usar aspas (""). Se não forem utilizadas as aspas, o R entenderá que você quer atribuir um objeto/variável a outro objeto/variável (que não existe) ou descrevendo um símbolo não esperado (como um espaço, símbolo ou letra acentuada). Um objeto da classe `character` pode realizar algumas ações, mas logicamente que ações que incluam cálculos não poderão ser realizadas. Veja no seu console os resultados dos comandos a seguir para que você visualize:

Erro com objeto não encontrado:

```{r, eval=F}
c <- valor
```


Erro com símbolo inesperado:

```{r, eval=F}
c <- valor nao esperado
```


Erro com argumento não-numérico:

```{r, eval=F}
2*c
```


Já um objeto lógico pode apresentar dois tipos de valores `TRUE` e `FALSE`. Esse é o objeto mais simples, pois só pode ser um valor ou outro, sendo que numericamente os valores lógicos podem ser: `TRUE` = `1` e `FALSE` = `0`. Portanto, podemos fazer a soma de dois ou mais valores lógicos:

```{r}
TRUE + FALSE + TRUE
```

Sendo essa característica muito útil, onde poderemos ver em exemplos futuros. Os valores de `TRUE` e `FALSE` devem ser escritos com todas as letras em caixa alta e também podem ser sintetizados no R com somente a primeira letra (`T` e `F`). 

```{r}
T
F
```

Os valores lógicos podem ser respostas a operadores lógicos, sendo eles: `==` (*igual a*), `!=` (*diferente a*), `>` (*maior que*), `<` (*menor que*), `>=` (*maior ou igual a*), `<=` (*menor ou igual a*). Exemplos:

```{r}
1==2
1!=2
1<2
1>2
1>=2
1<=2
```

- Construindo um `vector`:

Para construir uma sequência de valores que sejam atribuídos a uma única variável/objeto, use a função `c()` (de *combine*), colocando os valores separados por uma vírgula (`,`). Exemplos:

```{r}
vetor_a <- c(18.5, 22, 44.123456, pi)
vetor_b <- c("abc", "def GHIJ", "!23$ ¨¨(), qualquer", "difícil")
vetor_c <- c(TRUE, FALSE, T, F)
```

Sendo que cada vetor também tem sua classe:

```{r}
class(vetor_a)
class(vetor_b)
class(vetor_c)
```

**Observação**: o valor de $\pi$ já está presente no R como o objeto `pi`. 

Cada objeto pertencerá a uma classe de objetos que seja a mais inclusiva para todas as variáveis. Portanto, se você fizer um vetor que inclua `character` e `numeric`, todos os valores serão mudados para `character`. Exemplo:

```{r}
vetor_misto <- c("zero", 1, 2, 3)
class(vetor_misto)
```

A hierarquia no R é: `logical` < `integer` < `numeric` < `character`.


- Construindo um `data.frame`

Um data.frame é uma tabela de `n` x `m` (`n` linhas e `m` colunas), sendo que todas as `m` colunas devem ter o mesmo tamanho. Para construir um data.frame, basta usar a função `data.frame()`, juntando dois ou mais vetores. Exemplo:

```{r}
dados <- data.frame(vetor_a, vetor_c)
dados
```

possuindo a sua própria classe (`data.frame`):

```{r}
class(dados)
```

O interessante é que cada coluna mantém a sua classe dentro de um data.frame. Para visualizar isso, utilize a função `str()` (para ver a estrutura do data.frame) ou `summary()` (Para ver o *resumo* do data.frame):

```{r}
str(dados)
```

Com `str()` vemos que são duas colunas, uma intitulada `vetor_a` da classe `numerical` (podemos ver com a descrição `num`) e outra chamada `vetor_c` da classe `logical` (podemos ver `logi`). 

```{r}
summary(dados)
```

Com `summary()` vemos que são duas colunas, uma intitulada `vetor_a` com os seguintes valores:
    
    Valor Mínimo (`Min.`) igual a `3.142` 
    Primeiro quartil (`1st Qu.`) igual a `14.660`
    Mediana (`Median`) igual a `20.250`
    Média (`Mean`) igual a `21.941`
    Terceiro Quartil (`3rd Qu.`) igual a `27.531`
    Valor Máximo (`Max.`) igual a `44.123`

A segunda coluna intitulada `vetor_c` vemos que é uma coluna com valores lógicos (`Mode: logical`), contabilizando quantos valores de `TRUE` e `FALSE` existem (2, respectivamente).

Na hora de construirmos um data.frame, também podemos colocar nomes diferentes das colunas, desta maneira:

```{r}
dados <- data.frame(Numeros = vetor_a, 
                    Logico = vetor_c)
dados
```



### Usando indexação

Os dois principais objetos que usaremos para a indexação serão vetores e tabelas (`data.frame`). Para a indexação utiliza-se os colchetes (`[]`) e numeração para visualizarmos e/ou extrairmos os valores presentes nesses objetos. No R, o primeiro valor de um vetor é extraído usando o nome do vetor seguido por `[1]`. Caso fosse o segundo valor, usamos `[2]`, e assim por diante. Exemplo:


```{r}
vetor_letras <- c("primeiro", "segundo", "terceiro", "quarto", "quinto")
vetor_letras
vetor_letras[1]
vetor_letras[2]
```
Se quisermos extrair mais do que um valor, podemos utilizar um vetor de números ou uma sequência para extraí-los. Por exemplo, para extrairmos os valores `"primeiro"`, `"terceiro"` e `"quinto"`, utilizamos o vetor de numeros `c(1,3,5)` dentro dos colchetes, desta maneira:



```{r}
vetor_letras[c(1,3,5)]
```


Valores lógicos (`TRUE` e `FALSE`, ou `T` e `F`) também podem ser utilizados:

```{r}
vetor_letras[c(TRUE, FALSE, TRUE, FALSE, TRUE)]
```

Ou se quisermos extrairmos os valores entre `"segundo"` ao `"quarto"`, podemos fazer uma sequência entre 2 e 4, utilizando `2:4` (lê-se: sequência de numeros inteiros entre 2 e 4, espaçados por 1), desta maneira:

```{r}
vetor_letras[c(2:4)]
```

No caso de tabelas, temos duas dimensões: linhas e colunas. Dessa maneira, quando extraimos o valor presente na linha `2` coluna `3`, devemos utilizar `[2,3]`, sendo o primeiro valor referente a linha da tabela e o segundo valor, após a vírgula, referente a coluna.
Veja exemplo:

- 1o Criar um data.frame composto por sequências de números:

```{r}
tabela <- data.frame(Coluna_A = 1:20,
                     Coluna_B = 21:40,
                     Coluna_C = 41:60,
                     Coluna_D = 61:80,
                     Coluna_E = 81:100)
tabela
```
 
 Lembrando que usando `:` construimos uma sequência de números no intervalo descrito, e para colocar os nomes das colunas, basta colocar o nome da coluna e `=`, como construído acima.

- 2o Extrair o valor requerido (2a linha, 3a coluna):

```{r}
tabela[2,3]
```

Intervalos também podem ser utilizados. Por exemplo, extraindo as 6 primeiras linhas (`1` a `6`) e entre as colunas `3` e `5`.


```{r}
tabela[1:6, 3:5]
```

Se deixarmos o argumento de linha ou de coluna em branco, todas as linhas ou colunas vão ser disponibilizadas. Por exemplo:

**a)** Deixando o argumento de **linhas** em branco, selecionando a **coluna** 3:

```{r}
tabela[,3]
```

**b)** Deixando o argumento de **colunas** em branco, selecionando a **linha** 3:

```{r}
tabela[3,]
```



Em um data.frame também podemos isolar colunas usando `$`, desta maneira:

```{r}
tabela$Coluna_A
```


### Usando indexação e operadores lógicos

Podemos mesclar o conhecimento sobre indexação e o uso de operadores lógicos para selecionar somente uma parte de uma tabela. Para esse exemplo, utilizaremos os dados de `mtcars`, que podem ser obtidos diretamente no R usando a **função** `data()`. Dessa maneira:

```{r}
data("mtcars")
```

Podemos visualizar as primeiras 6 linhas dessa tabela usando a função `head()`:

```{r}
head(mtcars)
```

No caso desta tabela, cada linha tem um nome e referem-se aos nomes dos modelos de carros avaliados. Para ver mais informações sobre esses dados, você pode usar o comando `?mtcars` em seu console, ou ir até esse [link](https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/mtcars.html) (em inglês).


Se realizarmos um teste com operador lógico, observaremos como resposta uma série de `TRUE` ou `FALSE`. Veja o exemplo a seguir, para sabermos se existem carros com 6 cilindros (`cyl == 6`):


```{r}
mtcars$cyl == 6
```

Desta maneira, podemos extrair essa sequência (vetor) de valores lógicos (`TRUE`/`FALSE`) para um novo objeto chamado `carros_6cyl`:

```{r}
carros_6cyl <- mtcars$cyl == 6
```

E com esse vetor, utilizar para selecionar as linhas da tabela que seguem (com resposta igual a `TRUE`) o operador lógico executado (`mtcars$cyl == 6`):

```{r}
mtcars[carros_6cyl,]
```

Ou simplesmente podemos sintetizar esses comandos em um só (sem a construção do objeto `carros_6cyl`):

```{r}
mtcars[mtcars$cyl == 6, ]
```

        Não se esqueça que em data.frame existe a vírgula (`,`) para separar linha e coluna!

### Criando uma função

Lembre-se **sempre** que trabalhos repetitivos devem ser realizados pelo computador! Por isso, criar funções é muito importante para quem trabalha com bioinformática. Criar uma função é estabelecer um algoritmo criado por você! Então, veja como podemos construir um algoritmo e aplicá-lo com uma função.

Vamos supor que você queira calcular a área de um retangulo, que é simplesmente a multiplicação dos valores da base e da altura desse retângulo. Veja a figura abaixo sobre paralelogramas (Fonte: [Wikipedia](https://pt.wikipedia.org/wiki/Ficheiro:%C3%81rea_dos_Paralelogramos.png) )

![Figura 1 - Área dos Paralelogramas](https://upload.wikimedia.org/wikipedia/commons/0/03/%C3%81rea_dos_Paralelogramos.png)






## Exercícios

### Exercicio 1.
Fazer a Fórmula de Bhaskara segundo comando no R

### Exercicio 2.

#### a. `data(mtcars)`

#### b. veja quais carros tem:

b.1) `hp < 100`

b.2) `am = 1` (automatico)

b.3) `mpg > 20 & am == 0`

#### c. Usando `$`, `[]` e `:`

c.1) Veja entre as linhas `11` e `22` do df

c.2) veja entre as colunas `2` e `5` do df

c.3) Extraia os três primeiros valores da coluna `qsec`

c.4) Organize a tabela com o mpg maior para o menor, usando a função `sort()`. Use `?` para ajudar

### Exercicio 3.

Construa uma função que execute a formula de Bhaskara (exercicio 1).

### Exercicio 4.

Construa um grafico entre mpg e hp

#### a. x <- mpg

#### b. y <- hp

#### c. plot(x, y); plot(y ~ x)

Exercicio 5. 
a. Instalar o pacote tidyverse
b. Ler os dados compilados de series/filmes
c. Manipular para uma limpeza dos dados usando: mutate, as.logical, ifelse/case_when
d. usar filter para filtrar filmes/series dos ultimos 5 anos, 10 anos e 20 anos
e. usar select para selecionar duas colunas
f. criar nova coluna com mutate chamada de antigos (series/filmes > 20 anos)
g. Usar pipe (%>%)
h. Usar summarize/group_by para verificar a mediana/media do ano filmes/series por aluno
i. Usar arrange para ordenar os filmes/series

data("mtcars")
mtcars[order(mtcars$mpg, decreasing = F),] #se quiser colocar do menor para o maior usar decreasing=F
